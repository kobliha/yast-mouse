/**
 * Module: 		XF86Mouse.ycp
 *
 * Authors: 		Thomas Roelz <tom@suse.de>
 *
 * Purpose:		Provides several functions to write/alter the mouse settings 
 *			in the X11 configuration.
 *
 *
 * $Id$
 *
 * This module provides the following functions for public access via XF86Mouse::<func-name>(...)
 *
 * 	create_info_map()	- Create the map suitable for being passed to the isax-agent.
 *
 *	update()		- Update the XF86Config file.
 *
 * Remarks:
 *	Requires the modules Mouse and X11 to be up to date.
 *
 */
{
    module "XF86Mouse";
    textdomain "mouse";

    import "Mouse";
    import "Mode";

    // The XFree version has to be determined in different ways depending on mode.
    //

    /**
     * XF86Mouse()
     *
     * The module constructor.
     *
     * @param 	-
     *
     * @return  -
     *
     * @see	-
     */
    global define void XF86Mouse()
	``{
	// Nothing to be done here.
	//
	return;
    }

       
    
    /**
     * create_info_map()
     *
     * Creates a YCP map containing all the data necessary for writing the mouse section
     * of the rc.sax file via the isax agent.
     *
     * @param	-
     *
     * @return  The YCP map containing the mouse information to be passed to the isax agent.
     *
     * @see	update()
     */

    global define map create_info_map()
	``{
	// mouse protocol
	//
	string mouse_prot = Mouse::mset;

	if ( mouse_prot == "" || Mouse::mouse == "non" )	// if no mouse attached
	    mouse_prot = "AUTO";

	// mouse device
	//
	//string mouse_device = Mouse::device;
	//
	//if ( mouse_device == "" || Mouse::mouse == "non" )	// if no mouse attached
	//mouse_device = "/dev/mouse";
	//
	// According to ms@suse.de it is necessary to write the mouse device _link_ into
	// the XF86Config to allow the mouse reconfiguration from within the running system.
	// Applying the mouse via xmset does only work if this is the case. The X11 misc extension
	// used by xmset might be extended some day to allow apllying the mouse even if the
	// device in XF86Config is not a link bur until then...
	// Therefore we _always_ write "/dev/mouse" here for now.
	//
	string mouse_device = "/dev/mouse";

	// mouse wheels
	//
	integer mouse_wheels = Mouse::wheels;
	
        // raw buttons without wheel buttons. Only XFree 4.
	//
	integer mouse_buttons = Mouse::buttons;

        // including wheel buttons
	//
	string mouse_buttons_str = "" + ( mouse_buttons + ( 2 * mouse_wheels ) );

	// try to use a wheel if present
	//
	string mouse_opt = "";

	if ( mouse_wheels >= 1 )			// we do have a wheel mouse
	    mouse_opt = "ZAxisMapping:4 5";		// can be used "as is" for XFree 3

	// "emulate 3 buttons" is rather clumsy
	//
	string mouse_emu3btn = "";
  
	if ( Mouse::emul3 && mouse_buttons < 3 )	// emulate 3 buttons
	{
	    mouse_emu3btn = "yes";
	}
	else	// don't emulate 3 buttons
	{
	    mouse_emu3btn = "no";
	}

	// Create the info map for the isax-agent.
	//
	map info = $[
		     "MOUSEDEVICE"    : [ mouse_device, "Mouse device"],
		     "MOUSEPROT"      : [ mouse_prot, "Mouse protocol"],
		     "EMU3BTN"        : [ mouse_emu3btn, "Mouse 3 button emulation"],
		     "MOUSEOPT"       : [ mouse_opt, "Mouse options"],
		     "MOUSEBUTTONS"   : [ mouse_buttons_str, "Number of btns incl. wheel btns"]
	];

	return( info );
    }


    /**
     * update()
     *
     * Updates the mouse settings in the XF86Config file.
     *
     * !!! only XFree 4 !!!
     *
     *
     *
     * @param
     *
     * @return  true	- success
     *		false	- failure
     *
     * @see	create_info_map()
     */

    global define boolean update()
	``{
	// Create the map for the isax agent.
	//
	map info = create_info_map();

	y2milestone( "mouse_info: <%1>", info );

	// Call the isax agent to update the mouse settings in the XF86Config file.
	//
	any ret = SCR::Write( .xf86config.mouse, info );

	return( ret );
    }
}
